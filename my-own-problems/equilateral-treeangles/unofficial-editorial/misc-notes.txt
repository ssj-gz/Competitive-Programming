
Has some good features:
* Broad range of outputs that are chaotic wrt to input

Almost fell off my chair when I saw CHGORAM - count all triples of nodes satisfying conditions! But in the end, saved me having to come up with a story from scratch.

Testing hard part
* Simple cheat for O(N^2) solution was *devastatingly effective* on original tests
** Passed all of them with ease XD
** Back to the drawing board!
** 006-008 designed specifically to violate some reasonable assumptions, but had no particular "cheat" implementation in mind, so almost deleted them - very pleased I didn't, as they were often the "Last Men Standing", as it were, even against official Tester
*** Watching the Tester do his stuff is pretty nerve-wracking, incidentally - 013 and 014 are "mystery" tests designed by automated parameter-search to make his solution TLE as hard as they could - no idea how they work!
* Initial few hours were demoralising; seemed to be an endless procession of people effortlessly dunking on it.  I kind of lost faith in the Problem, then, and wished I hadn't submitted it
** Ultimately, though, surprisingly few people were able to solve it during the course of the Contest!

# Problem History

@shivank98 came up with this idea [a while back](https://discuss.codechef.com/t/approach-for-question-making/37519), and I thought it was a good one, so I'm take a stab at it :)

[TODO - image here]

Oddly, CHGORAM2 arose out of my disatisfaction with a Hackerrank problem called ["Find the Nearest Clone"](https://www.hackerrank.com/challenges/find-the-nearest-clone/problem).  It would be a neat Easy-Medium question except for the fact that is utterly let down by its [legendarily](https://www.hackerrank.com/challenges/find-the-nearest-clone/forum/comments/592337) [poor](https://www.hackerrank.com/challenges/find-the-nearest-clone/forum/comments/605904) testcases - or rather, more fundamentally, by the fact that the Setter/ Editorialist did not realise that his purportedly $O(N)$ solution was in fact $O(N^2)$.

I brainstormed ways of coming up with a tweak to the Problem that would enable me to re-do it (this time with decent testcases!) - perhaps count the number of ways of forming this closest pair? Or finding not the nearest *pair* of clones, but the nearest *triples* - triples of nodes who all have the same (minimum) distance from each other? Or perhaps counting all such triples? Or - maybe! - counting *all* triples of the same type??

This latter seemed more plausible (for a tree, at least - not for an arbitrary graph as in the original Find the Nearest Clone!), and eventually I stripped it down to just two types: at the time, as you can see from the commit, I had a lame backstory in mind where the nodes were houses, and some houses had people in them, and you have to count the number of equidistant triples of people - something about the people in this town preferring to gather in triples and, out of a sense of fairness, wanted the journey time between any pairs of friend's houses to be the same, or somesuch nonsense :) It was to be called "Equilateral Treeangles" (groan).

Strangely for me, I came up with the basic approach - the Type A arrangement, countable using a DFS with the Small-to-Large optimisation used with descendent heights - almost straight away.  My git logs from around the time explicitly mention [this](https://www.hackerrank.com/challenges/coloring-tree/problem) Hackerrank Problem, so I suppose by chance I was thinking about it at this time, and that steered my thoughts in the right direction.  Of course, I didn't get it completely correctly initially - I completely overlooked the existence of Type B arrangements (ha!) and also assumed that the "p" in the Type A case would always be a direct ancestor of X (lol), but the fact that this latter wasn't the case was actually good - it made the problem much deeper, as now it seemed to required Centroid Decomposition, too!

Actually implementing it didn't take too long - there was one heart-stopping moment where a test-run of my implementation took about 5 seconds on a testcase I generated (the git log at the time contains "I've gravely misjudged something, but don't yet know what.  Panic stations!"), but it turns out that I just had the direction of a "<" reversed and was doing the Large-to-Small Pessimisation instead of the Small-to-Large Optimisation XD

I then put the Problem on hold for a while, and took part in my first Codechef contest (AUG19B).  One of the most heartbreaking things that can happen when you've invested a lot of time and effort in your own Problem is to find that someone has beaten you to it, and so I nearly fell off my chair when I came across a Problem where you had count the number of ways (eep!) of choosing 3 nodes (ulp!) on a tree (gulp!) satisfying certain constraints (yikes!), but after taking some deep breaths and forcing myself to read the Problem carefully, I saw that this "CHGORAM" Problem was completely different to mine and breathed a sigh of relief.  Even better, as I realised a little later - I could ditch my naff backstory about triples of fair-minded friends and piggy-back on this one instead!

So: I had a working implementation with the "<" pointing the right way, and a backstory - time to get some proper tests written, which would prove to be by far the hardest part of the Problem.

My shiny new testcases were being passed with ease by my Editorial implementation, so I tested it with an obvious O(N^2) implementation: one where we consider each node in turn as the "centre" of the triple (the "X") and find all nodes at given distance from X, reachable via different neighbours of X, and count the triples that can be formed by all of these that are suitable.  Happily, the testcases TLE'd heavily on this naive approach, but then I suddenly (much later than most of you, I'm sure) noticed the Achilles' heel for this Problem: if, at any point, we *cannot* find 3 nodes at distance $d$ from X reachable by different children of X, then we can stop our search there - subsequent $d$s will reveal no further triples.

I added this small optimisation to the "cheat" $O(N^2)$ solution and ... it absolutely wrecked my testcases.  Just blasted through all of them, taking barely more than 1 sec for the hardest.  Back to the drawing board! 

I had to exercise a bit of ingenuity (and up the node limit to $200,000$ XD) to break this Cheat Solution, but this was still a bit of a crisis - if such a simple ploy could have obliterated my original testcases,  then maybe a slightly less simple one would destroyed the new ones? I tried to be as proactive about anticipating avenues that could be exploited as I could, and also wrote a few "blue-sky" tests (006-008) that violated some core assumptions as hard as they could.  I couldn't really come up with any plausible implementation that could use these assumptions to cheat, and so was quite close to deleting tests 006-008 but, as it happens, 008 at least turned out to be oddly effective :) 015 was also a last-minute reaction to a possible attack that I thought of, but proved less useful.

Anyway, I had all the ingredients ready now so I submitted the Problem Idea, which was Approved very quickly and fast-tracked to appear in FEB20th where it would be one of the Div 1-only Problems - which made me nervous, as I was still unsure about how easily the "Achilles' Heel" would permit sub-optimal solutions.  Watching it get Tested by the Tester was very nerve-wracking, and for a while it looked like the Tester was going to trounce it in very short order, but in fact, it was here that the almost-deleted 008 first proved its mettle, by being the Last Man Standing for one of the Tester's early attempts!

After a while, I couldn't stand the tension anymore and went to sleep - as expected, the Tester had broken it by the time I woke up, but it had put up a good fight, at least, and made him work for it! His assessment was "medium or hard (although probably closer to hard)", which was reassuring.  He did suggest to toughen up some of the tests, and this is where the mysterious 013 and 014 were born - they came about through setting up the testcase generator to generate trees with certainly parameters, and then doing a random parameter search to see which combination caused the Setter's "cheat" implementation to time-out the hardest.  To this day, I still don't have the slightest clue how 013 and 014 actually work, but they proved very effective against the Tester's solution, and indeed many solutions during the Contest!

My confidence in the Problem had been bolstered by now, so I was quite panicked when the first few hours of the Contest consisted of what seemed like an endless parade of people effortlessly dunking on the it XD I was debating writing this Problem History as a long "sorry my testcases sucked" apology, but eventually the parade dried up a little (and digging through these early submitter's histories revealed them as either official 7*'s, or people who will surely be 7* after a few more contests - unless they elect to take the @just1star route, of course :)) and in the end far, far fewer people managed to complete it - approx 1/4 as many as the original CHGORAM, in fact :) The 008 testfile again proved surprisingly effective, and I'm very glad I didn't delete it.  

From looking at some of the solutions, it quickly became clear that my solution was unnecessarily clumsy, so I've only given it a little bit of documentation compared to my normal solutions - please refer to the official Editorial instead :)

Anyway, that's that - all a bit of a roller-coaster, but I'm glad I finally got a Problem published somewhere and it didn't turn out to be a disgrace ;)
